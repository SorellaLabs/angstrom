--- crates/types/src/matching/composite.rs
+++ replace CompositeOrder<'a>::calc_quantities -> (u128, u128) with (0, 1)
@@ -38,34 +38,17 @@
         self.amm.as_ref()
     }
 
     pub fn bound(&self) -> Option<Ray> {
         self.bound_price
     }
 
     pub fn calc_quantities(&self, target_price: Ray) -> (u128, u128) {
-        debug!(target_price = ?target_price, "Calculating quantities to target price");
-        let amm_q = self
-            .amm
-            .as_ref()
-            .map(|a| a.vec_to(target_price.into()).unwrap().d_t0)
-            .unwrap_or_default();
-        let debt_q = self
-            .debt
-            .map(|d| d.dq_to_price(&target_price))
-            .unwrap_or_default();
-        debug!(amm_q, debt_q, "Calculated quantities");
-        if let Some(a) = self.amm.as_ref() {
-            debug!(amm_price = ?Ray::from(a.price()), liquidity = a.liquidity(), "AMM final stats");
-        }
-        if let Some(d) = self.debt.as_ref() {
-            debug!(debt_price = ?d.price(), "Debt final stats");
-        }
-        (amm_q, debt_q)
+        (0, 1) /* ~ changed by cargo-mutants ~ */
     }
 
     fn find_closest_bound(&self, external_bound: Ray) -> Ray {
         if let Some(ib) = self.bound_price {
             let cur_price = self.start_price();
             let external_dp = external_bound.abs_diff(*cur_price);
             let internal_dp = ib.abs_diff(*cur_price);
             if internal_dp < external_dp {
