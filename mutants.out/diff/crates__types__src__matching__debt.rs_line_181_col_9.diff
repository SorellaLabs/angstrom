--- crates/types/src/matching/debt.rs
+++ replace Debt::price_range -> (Ray, Ray) with (Default::default(), Default::default())
@@ -173,38 +173,17 @@
     /// quantity calculations to ensure we don't over or underfill orders
     pub fn slack(&self) -> u128 {
         self.magnitude.slack_at_price(self.cur_price)
     }
 
     /// Given the Debt's direction and rounding, return the low and high price
     /// that will result in an exchange for an identical amount of T0
     pub fn price_range(&self) -> (Ray, Ray) {
-        let current_amount = self.current_t0();
-        let bound_amount = match self.magnitude {
-            DebtType::ExactIn(_) => current_amount + 1,
-            DebtType::ExactOut(_) => current_amount.saturating_sub(1)
-        };
-        debug!(current_amount, bound_amount, "Getting price range between targets");
-        let (current_price, bound_price) = match (current_amount, bound_amount) {
-            // If both values are zero, something is hecka wrong
-            (0, 0) => (Ray::min_uniswap_price(), Ray::max_uniswap_price()),
-            // If either value is 0, one of our bounds is max price
-            (0, p) | (p, 0) => (
-                Ray::max_uniswap_price(),
-                Ray::calc_price_generic(p, self.magnitude(), self.magnitude.round_up())
-            ),
-            // Otherwise we can just do our normal math
-            (c, b) => (
-                Ray::calc_price_generic(c, self.magnitude(), self.magnitude.round_up()),
-                Ray::calc_price_generic(b, self.magnitude(), self.magnitude.round_up())
-            )
-        };
-        let (low, high) = low_to_high(&current_price, &bound_price);
-        (*low, *high)
+        (Default::default(), Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     /// Will return true if the price provided is equivalent to the current
     /// price of this debt due to the rounding innate to performing the actual
     /// transaction
     pub fn valid_for_price(&self, price: Ray) -> bool {
         let (low, high) = self.price_range();
         debug!(low = ?low, high = ?high, "Validating for price range");
