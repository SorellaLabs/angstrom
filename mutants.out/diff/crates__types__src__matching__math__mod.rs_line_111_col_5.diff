--- crates/types/src/matching/math/mod.rs
+++ replace price_intersect_solve -> Integer with Default::default()
@@ -103,56 +103,17 @@
 /// their prices end up as close as possible
 pub fn price_intersect_solve(
     amm_liquidity: u128,
     amm_price: SqrtPriceX96,
     debt_fixed_t1: u128,
     debt_price: Ray,
     direction: Direction
 ) -> Integer {
-    debug!(amm_liquidity, amm_price = ?amm_price, debt_t1 = debt_fixed_t1, debt_price = ?debt_price, "Price intersect solve");
-    let l = Integer::from(amm_liquidity);
-    let l_squared = (&l).pow(2);
-    let amm_sqrt_price_x96 = Integer::from(Natural::from_limbs_asc(amm_price.as_limbs()));
-    let debt_magnitude = Integer::from(debt_fixed_t1);
-
-    // The precision we want to use for this operation, depending on our common
-    // values we might need to adjust this
-    let precision: usize = 192;
-
-    // a = 1/L^2
-    let a_frac = Rational::from_integers_ref(&(Integer::ONE << precision), &l_squared);
-    let a = Integer::rounding_from(a_frac, RoundingMode::Nearest).0;
-    debug!(a = ?a, "A factor");
-
-    // b = [ 2/(L*sqrt(Pa)) - 1/(T1d) ]
-    let b_first_part = Rational::from_integers_ref(
-        &(Integer::TWO << (96 + precision)),
-        &(&l * &amm_sqrt_price_x96)
-    );
-    let b_second_part = Rational::from_integers_ref(&(Integer::ONE << precision), &debt_magnitude);
-    let b = Integer::rounding_from(b_first_part - b_second_part, RoundingMode::Nearest).0;
-    debug!(b = ?b, "B factor");
-
-    // c = [ 1/Pa - 1/Pd ]
-    // Precision is x96
-    let c_part_1 = Rational::from_integers(
-        Integer::ONE << (192 + precision),
-        Integer::from(Natural::from_limbs_asc(amm_price.as_price_x192().as_limbs()))
-    );
-    // Precision is x96
-    let c_part_2 = Rational::from_integers(
-        (Integer::ONE * Integer::from(const_1e27())) << precision,
-        Integer::from(Natural::from_limbs_asc(debt_price.as_limbs()))
-    );
-    let c = Integer::rounding_from(c_part_1 - c_part_2, RoundingMode::Nearest).0;
-    debug!(c = ?c, "C factor");
-
-    let solution = quadratic_solve(a, b, c, precision);
-    solution.0.or(solution.1).unwrap()
+    Default::default() /* ~ changed by cargo-mutants ~ */
 }
 
 pub fn quadratic_solve(
     a: Integer,
     b: Integer,
     c: Integer,
     precision: usize
 ) -> (Option<Integer>, Option<Integer>) {
