--- crates/types/src/matching/math/mod.rs
+++ replace quadratic_solve -> (Option<Integer>, Option<Integer>) with (Some(Default::default()), None)
@@ -151,44 +151,17 @@
 }
 
 pub fn quadratic_solve(
     a: Integer,
     b: Integer,
     c: Integer,
     precision: usize
 ) -> (Option<Integer>, Option<Integer>) {
-    let numerator = (&c * &Integer::TWO) << precision;
-    let b_squared = b.clone().pow(2);
-    let four_a_c = Integer::from(4_u128) * a * c;
-    let sqrt_b24ac = Integer::floor_sqrt(&b_squared - &four_a_c);
-    let neg_b = b.neg();
-
-    // Find our denominators for both the + and - solution
-    let denom_minus = &neg_b - &sqrt_b24ac;
-    let denom_plus = &neg_b + &sqrt_b24ac;
-    debug!(numerator = ?numerator, denom_plus = ?denom_plus, denom_minus = ?denom_minus, "Quadratic solve factors");
-
-    // Save ourselves from zeroes
-    match (denom_plus == Integer::ZERO, denom_minus == Integer::ZERO) {
-        (true, true) => panic!("Both denominators in quadratic solve were zero, this math sucks"),
-        // Just one that's valid, return that
-        (false, true) => (None, Some(numerator.div_round(&denom_plus, RoundingMode::Nearest).0)),
-        // Just one that's valid, return that
-        (true, false) => (Some(numerator.div_round(&denom_minus, RoundingMode::Nearest).0), None),
-        // Both valid, compare and return the best option
-        (false, false) => {
-            let answer_plus = numerator
-                .clone()
-                .div_round(&denom_plus, RoundingMode::Nearest)
-                .0;
-            let answer_minus = numerator.div_round(&denom_minus, RoundingMode::Nearest).0;
-            (Some(answer_minus), Some(answer_plus))
-        }
-    }
+    (Some(Default::default()), None) /* ~ changed by cargo-mutants ~ */
 }
 
 pub fn resolve_precision(precision: usize, number: Integer, rm: RoundingMode) -> u128 {
     number
         .div_round(Integer::power_of_2(precision as u64), rm)
         .0
         .unsigned_abs_ref()
         .saturating_into()
