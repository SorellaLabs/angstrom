--- crates/types/src/matching/uniswap/poolprice.rs
+++ replace PoolPrice<'a>::intersect_with_debt -> eyre::Result<u128> with Ok(1)
@@ -188,46 +188,17 @@
         self.vec_to(SqrtPriceX96::at_tick(self.liq_range.lower_tick)?)
     }
 
     /// Determine the quantity of t0 needed to bring this price to the price of
     /// the given Debt
     pub fn intersect_with_debt(&self, debt: Debt) -> eyre::Result<u128> {
         // If the debt is already valid at our current price we can just move it, we're
         // done
-        if debt.valid_for_price(self.as_ray()) {
-            return Ok(0)
-        }
-        // Find out how much it would take to intersect with our debt presuming we stay
-        // within our current liquidity range
-        let vec_to_upper = self.to_liq_range_upper()?;
-        let next_range_start = vec_to_upper.end_bound;
-        let t0_to_upper = vec_to_upper.d_t0;
-        let solve = price_intersect_solve(
-            self.liquidity(),
-            self.price,
-            debt.magnitude(),
-            debt.price(),
-            Direction::BuyingT0
-        );
-        debug!(solve = ?solve, "Solve");
-        let step = resolve_precision(192, solve, RoundingMode::Floor);
-        debug!(step, "Step");
-        if step < t0_to_upper {
-            return Ok(step)
-        }
-        let new_debt = debt.partial_fill(step);
-        // If our next range is in another liquidity pool
-        let recurse = if next_range_start.liq_range.lower_tick != self.liq_range.lower_tick {
-            next_range_start.intersect_with_debt(new_debt)?
-        } else {
-            0
-        };
-
-        Ok(step + recurse)
+        Ok(1) /* ~ changed by cargo-mutants ~ */
     }
 
     /// This will produce a Uniswap Price Range that spans from the current
     /// price to the CLOSER of the target price or the nearest liquidity
     /// pool boundary
     ///
     /// This might not be needed anymore now that our poolpricevec can handle
     /// multiple liquidity pools
