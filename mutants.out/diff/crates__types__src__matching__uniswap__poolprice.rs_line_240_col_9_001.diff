--- crates/types/src/matching/uniswap/poolprice.rs
+++ replace PoolPrice<'a>::order_to_target -> Option<PoolPriceVec<'a>> with None
@@ -232,75 +232,17 @@
     /// This might not be needed anymore now that our poolpricevec can handle
     /// multiple liquidity pools
     pub fn order_to_target(
         &self,
         target_price: Option<SqrtPriceX96>,
         buy: bool
     ) -> Option<PoolPriceVec<'a>> {
         // Bounds check our target price if provided
-        if let Some(p) = target_price {
-            if buy {
-                // Buying from the market will raise the price, so if our target price is on the
-                // wrong side of our current price, we can't do this.
-                if p <= self.price {
-                    return None;
-                }
-            } else {
-                // Selling to the market will lower the price, so the same applies here
-                if p >= self.price {
-                    return None;
-                }
-            }
-        }
-
-        let mut new_range_idx = self.liq_range.range_idx;
-        let mut pool = self.liq_range.range;
-        let (mut tick_bound_price, next_tick) = if buy {
-            let upper_tick_price = get_sqrt_ratio_at_tick(pool.upper_tick)
-                .ok()
-                .map(SqrtPriceX96::from)?;
-            let next_tick = self.liq_range.range_idx.checked_sub(1);
-            (upper_tick_price, next_tick)
-        } else {
-            let lower_tick_price = get_sqrt_ratio_at_tick(pool.lower_tick)
-                .ok()
-                .map(SqrtPriceX96::from)?;
-            let next_tick = self.liq_range.range_idx.checked_add(1);
-            (lower_tick_price, next_tick)
-        };
-        if self.price == tick_bound_price {
-            // We're at the tick bound, we need to look at the next pool!
-            new_range_idx = next_tick?;
-            pool = self.liq_range.pool_snap.ranges.get(new_range_idx)?;
-            tick_bound_price = if buy {
-                get_sqrt_ratio_at_tick(pool.upper_tick)
-                    .ok()
-                    .map(SqrtPriceX96::from)?
-            } else {
-                get_sqrt_ratio_at_tick(pool.lower_tick)
-                    .ok()
-                    .map(SqrtPriceX96::from)?
-            };
-        }
-        let closest_price = if let Some(p) = target_price {
-            if buy {
-                min(p, tick_bound_price)
-            } else {
-                max(p, tick_bound_price)
-            }
-        } else {
-            tick_bound_price
-        };
-        let end_bound = Self {
-            liq_range: LiqRangeRef { range: pool, range_idx: new_range_idx, ..self.liq_range },
-            price:     closest_price,
-            tick:      get_tick_at_sqrt_ratio(closest_price.into()).ok()?
-        };
-        Some(PoolPriceVec::new(self.clone(), end_bound))
+        None /* ~ changed by cargo-mutants ~ */
     }
 
     pub fn price(&self) -> &SqrtPriceX96 {
         &self.price
     }
 
     /// Return the current price as a Ray
     pub fn as_ray(&self) -> Ray {
