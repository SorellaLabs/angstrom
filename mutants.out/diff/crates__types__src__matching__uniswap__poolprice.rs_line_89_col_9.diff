--- crates/types/src/matching/uniswap/poolprice.rs
+++ replace PoolPrice<'a>::d_t0 -> eyre::Result<Self> with Ok(Default::default())
@@ -81,98 +81,17 @@
     pub fn liquidity(&self) -> u128 {
         self.liq_range.liquidity
     }
 
     /// Presuming a transaction in T0, return a new PoolPrice.  We error
     /// if we're not able to move enough in the direction we want to.
     pub fn d_t0(&self, quantity: u128, direction: Direction) -> eyre::Result<Self> {
         // We can short-circuit for a transaction of zero
-        if quantity == 0 {
-            return Ok(self.clone())
-        }
-        // Otherwise let's calculate
-        let mut sqrt_ratio_current_x_96 = self.price.into();
-        debug!(current_price = ?sqrt_ratio_current_x_96, "Current price");
-        let mut active_liq_range: Option<LiqRangeRef<'a>> = None;
-        let mut cur_quantity = U256::from(quantity);
-        while cur_quantity > U256::ZERO {
-            debug!("Starting new loop");
-            // There might be a more suave way to do this
-            let cur_liq_range = if let Some(lqr) = active_liq_range.as_mut() {
-                debug!("Bumping forward liquidity range");
-                // If we already tested a liquidity range let's move to the next one
-                let new_lqr = lqr.next(direction).ok_or_else(|| {
-                    eyre!("Unable to find liquidity ranges that span the whole transaction")
-                })?;
-                *lqr = new_lqr;
-                new_lqr
-            } else {
-                // Otherwise we can use the one we started in because this is the first
-                // iteration
-                active_liq_range = Some(self.liq_range);
-                self.liq_range
-            };
-            let amount_remaining = match direction {
-                // T0 when buying T0 is exact out (represented as a negative number in
-                // compute_swap_step)
-                Direction::BuyingT0 => I256::unchecked_from(cur_quantity) * I256::MINUS_ONE,
-                // T0 when selling T0 is exact in (represented as a positive number in
-                // compute_swap_step)
-                Direction::SellingT0 => I256::unchecked_from(cur_quantity)
-            };
-            debug!(
-                lower_tick = cur_liq_range.lower_tick,
-                upper_tick = cur_liq_range.upper_tick,
-                "Current liq range"
-            );
-            let sqrt_ratio_target_x_96 = cur_liq_range.end_price(direction).price.into();
-            debug!(cur_quantity = ?cur_quantity, amount_remaining = ?amount_remaining, target_price = ?sqrt_ratio_target_x_96, "Settings before compute_swap_step");
-            let (new_price, amount_in, amount_out, _) = compute_swap_step(
-                sqrt_ratio_current_x_96,
-                sqrt_ratio_target_x_96,
-                cur_liq_range.liquidity(),
-                amount_remaining,
-                0
-            )?;
-
-            // If we didn't hit our target and we didn't use all of our quantity then we've
-            // hit a weird error
-            if new_price != sqrt_ratio_current_x_96 {
-                match direction {
-                    Direction::BuyingT0 => {
-                        if amount_out < cur_quantity {
-                            return Err(eyre!("Bad stuff"));
-                        }
-                    }
-                    Direction::SellingT0 => {
-                        if amount_in < cur_quantity {
-                            return Err(eyre!("Bad stuff"));
-                        }
-                    }
-                }
-            }
-            debug!(next_price = ?new_price, amount_in = ?amount_in, amount_out = ?amount_out, "Settings after compute_swap_step");
-            // Update our current quantity
-            match direction {
-                Direction::BuyingT0 => cur_quantity -= amount_out,
-                Direction::SellingT0 => cur_quantity -= amount_in
-            }
-            // Update our current price
-            sqrt_ratio_current_x_96 = new_price;
-        }
-        // Convert our final elements into a new price element
-        let price = SqrtPriceX96::from(sqrt_ratio_current_x_96);
-        let tick = price.to_tick()?;
-        let liq_range = active_liq_range.ok_or_else(|| {
-            eyre!("Somehow have no active liquidity range despite iterationg - should never happen")
-        })?;
-        debug!(final_price = ?price, "Final price");
-        let new_price = PoolPrice::checked_new(liq_range, price, tick);
-        Ok(new_price)
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     /// Create a PoolPriceVec from the current price to a specific target price
     /// value within the associated Pool
     pub fn vec_to(&self, end_price: SqrtPriceX96) -> eyre::Result<PoolPriceVec<'a>> {
         PoolPriceVec::to_price_bound(self.clone(), end_price)
     }
 
