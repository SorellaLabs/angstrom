--- crates/types/src/matching/uniswap/poolpricevec.rs
+++ replace PoolPriceVec<'a>::to_upper -> eyre::Result<Self> with Ok(Default::default())
@@ -256,27 +256,17 @@
             PoolPrice { liq_range: l.liq_range, price: l.end_price, tick }
         } else {
             return Err(eyre!("Unable to find actual end price"))
         };
         Self::from_steps(start, end, steps)
     }
 
     pub fn to_upper(start: PoolPrice<'a>) -> eyre::Result<Self> {
-        let end = if let Some(range) = start
-            .liq_range
-            .pool_snap
-            .get_range_for_tick(start.liq_range.upper_tick)
-        {
-            range.start_price(Direction::BuyingT0)
-        } else {
-            start.liq_range.end_price(Direction::BuyingT0)
-        };
-        let steps = vec![SwapStep::to_bound(start.clone(), Direction::BuyingT0)?];
-        Self::from_steps(start, end, steps)
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     fn from_steps(
         start: PoolPrice<'a>,
         end: PoolPrice<'a>,
         steps: Vec<SwapStep<'a>>
     ) -> eyre::Result<Self> {
         let (d_t0, d_t1) = steps.iter().fold((0_u128, 0_u128), |(t0, t1), step| {
