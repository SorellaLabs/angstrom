--- crates/types/src/matching/uniswap/poolpricevec.rs
+++ replace PoolPriceVec<'a>::donation -> DonationResult with Default::default()
@@ -369,89 +369,17 @@
         }
 
         let (d_t0, d_t1) = direction.sort_tokens(total_in.to(), total_out.to());
         let end_bound = start.liq_range.pool_snap.at_price(current_price)?;
         Ok(Self { start_bound: start, end_bound, d_t0, d_t1, steps: Some(steps) })
     }
 
     pub fn donation(&self, q: u128) -> DonationResult {
-        let mut remaining_donation = U256::from(q);
-        let mut cur_q = U256::ZERO;
-        let mut filled_price = self
-            .steps
-            .as_ref()
-            .and_then(|v| v.first().map(|s| s.avg_price()))
-            .unwrap_or_default();
-        let empty = vec![];
-        let steps = self.steps.as_ref().unwrap_or(&empty);
-        let mut step_iter = steps.iter().peekable();
-        while let Some(step) = step_iter.next() {
-            let q_step = cur_q + U256::from(step.output());
-            // Our target price is either the average price of the next stake or the end
-            // price of the current stake if there's no next stake to deal with
-            let target_price = step_iter
-                .peek()
-                .map(|next_stake| next_stake.avg_price())
-                .unwrap_or_else(|| Ray::from(step.end_price));
-            // The difference between this tick's average price and our target price
-            let d_price = target_price - step.avg_price();
-
-            // The step cost is the total cost in needed to ensure that all sold quantities
-            // were sold at our target price
-            let step_cost = d_price.mul_quantity(q_step);
-
-            if remaining_donation >= step_cost {
-                // If we have enough bribe to pay the whole cost, allocate that and step forward
-                // to the next price gap
-                cur_q = q_step;
-                filled_price = target_price;
-                remaining_donation -= step_cost;
-            } else {
-                // If we don't have enough bribe to pay the whole cost, figure out where the
-                // target price winds up based on what we do have and end this iteration
-                if remaining_donation > U256::ZERO {
-                    let partial_dprice = Ray::calc_price(q_step, remaining_donation);
-                    filled_price += partial_dprice;
-                }
-                break
-            }
-        }
-
-        // We've now found our filled price, we can allocate our reward to each tick
-        // based on how much it costs to bring them up to that price.
-        let mut total_donated = U256::ZERO;
-        let tick_donations: HashMap<Tick, U256> = steps
-            .iter()
-            //.filter_map(|(p_avg, _p_end, q_out, liq)| {
-            .filter_map(|step| {
-                // We always donate to the lower tick of our liquidity range as that is the
-                // appropriate initialized tick to target
-                let tick_num = step.liq_range.lower_tick();
-                if filled_price > step.avg_price() {
-                    let tick_dprice = filled_price - step.avg_price();
-                    let tick_reward = tick_dprice.mul_quantity(U256::from(step.output()));
-                    if tick_reward > U256::ZERO {
-                        total_donated += tick_reward;
-                        Some((tick_num, tick_reward))
-                    } else {
-                        None
-                    }
-                } else {
-                    None
-                }
-            })
-            .collect();
-        let tribute = q.saturating_sub(total_donated.saturating_to());
-        DonationResult {
-            tick_donations,
-            final_price: self.end_bound.as_sqrtpricex96(),
-            total_donated: total_donated.saturating_to(),
-            tribute
-        }
+        Default::default() /* ~ changed by cargo-mutants ~ */
     }
 
     // Seems to be unused
     pub fn to_price(&self, target: SqrtPriceX96) -> Option<Self> {
         let (start_in_bounds, end_in_bounds) = if self.is_buy() {
             (Ordering::Greater, Ordering::Less)
         } else {
             (Ordering::Less, Ordering::Greater)
