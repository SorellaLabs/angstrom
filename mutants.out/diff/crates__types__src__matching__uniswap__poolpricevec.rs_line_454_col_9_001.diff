--- crates/types/src/matching/uniswap/poolpricevec.rs
+++ replace PoolPriceVec<'a>::to_price -> Option<Self> with Some(Default::default())
@@ -446,36 +446,17 @@
             final_price: self.end_bound.as_sqrtpricex96(),
             total_donated: total_donated.saturating_to(),
             tribute
         }
     }
 
     // Seems to be unused
     pub fn to_price(&self, target: SqrtPriceX96) -> Option<Self> {
-        let (start_in_bounds, end_in_bounds) = if self.is_buy() {
-            (Ordering::Greater, Ordering::Less)
-        } else {
-            (Ordering::Less, Ordering::Greater)
-        };
-        if self.start_bound.price.cmp(&target) == start_in_bounds {
-            if self.end_bound.price.cmp(&target) == end_in_bounds {
-                // If the target price is between the start and end bounds, make a subvec
-                let new_upper = self.start_bound.liq_range.pool_snap.at_price(target).ok()?;
-                Some(Self::new(self.start_bound.clone(), new_upper))
-            } else {
-                // If the target price is beyond the end bound in the appropriate direction,
-                // return a copy of this existing vector
-                Some(self.clone())
-            }
-        } else {
-            // If the target price is equal to or beyond the start price in an inappropriate
-            // direction, there is no vector to be made
-            None
-        }
+        Some(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     /// A very raw delta to a specific price presuming the liquidity is constant
     /// for the duration of the swap
     fn delta_to_price(
         start_price: SqrtPriceX96,
         end_price: SqrtPriceX96,
         liquidity: u128
