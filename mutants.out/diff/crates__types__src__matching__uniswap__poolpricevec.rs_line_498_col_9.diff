--- crates/types/src/matching/uniswap/poolpricevec.rs
+++ replace PoolPriceVec<'a>::quantity -> (u128, u128, OrderPrice) with (0, 0, Default::default())
@@ -490,26 +490,17 @@
     }
 
     pub fn is_buy(&self) -> bool {
         self.start_bound.price < self.end_bound.price
     }
 
     /// Returns `(d_t0, d_t1, price)`
     pub fn quantity(&self, target_price: OrderPrice) -> (u128, u128, OrderPrice) {
-        let t: SqrtPriceX96 = Ray::from(*target_price).into();
-
-        // If our target price is past our end bound, our quantity is the entire range
-        if (self.is_buy() && t > self.end_bound.price) || t < self.end_bound.price {
-            return (self.d_t0, self.d_t1, OrderPrice::from(self.end_bound.price));
-        }
-
-        let (d_t0, d_t1) =
-            Self::delta_to_price(self.start_bound.price, t, self.start_bound.liquidity());
-        (d_t0, d_t1, target_price)
+        (0, 0, Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     // Maybe it's OK that I don't check the price again here because in the matching
     // algo I've only offered a quantity bounded by the price, so we should
     // always be OK?
     pub fn fill(&self, quantity: u128) -> Self {
         let liquidity = self.start_bound.liquidity();
         let end_sqrt_price = if self.is_buy() {
